<!-- Working on listSTLURL and listNamesSTLs so they can import to CreateScene and add checkboxes -->
<!DOCTYPE html>
<html>
    <!-- #region fold -->
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

        <title>m3D 2D Viewer</title>

        <!-- Babylon.js -->
        <script src="https://code.jquery.com/pep/0.4.2/pep.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.6.2/dat.gui.min.js"></script>
        <script src="https://preview.babylonjs.com/ammo.js"></script>
        <script src="https://preview.babylonjs.com/cannon.js"></script>
        <script src="https://preview.babylonjs.com/Oimo.js"></script>
        <script src="https://preview.babylonjs.com/libktx.js"></script>
        <script src="https://preview.babylonjs.com/earcut.min.js"></script>
        <script src="https://preview.babylonjs.com/babylon.js"></script>
        <script src="https://preview.babylonjs.com/inspector/babylon.inspector.bundle.js"></script>
        <script src="https://preview.babylonjs.com/materialsLibrary/babylonjs.materials.min.js"></script>
        <script src="https://preview.babylonjs.com/proceduralTexturesLibrary/babylonjs.proceduralTextures.min.js"></script>
        <script src="https://preview.babylonjs.com/postProcessesLibrary/babylonjs.postProcess.min.js"></script>
        <script src="https://preview.babylonjs.com/loaders/babylonjs.loaders.js"></script>
        <script src="https://preview.babylonjs.com/serializers/babylonjs.serializers.min.js"></script>
        <script src="https://preview.babylonjs.com/gui/babylon.gui.min.js"></script>
		<!--<script src="jquery.min.js"></script>-->
		<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>

        <!-- DICOM parsing -->
        <!--<script src="dicomParser.min.js"></script>-->
		<script src="https://colincurtis.github.io/2D_Viewer/dicomParser.min.js"></script>
        <!--<script>window.dicomParser || document.write('<script src="https://unpkg.com/dicom-parser">\x3C/script>')</script>-->
        <!-- pako - needed to support deflated transfer syntax -->
        <!--<script src="pako.min.js"></script>-->
		<script src="https://colincurtis.github.io/2D_Viewer/pako.min.js"></script>
        <!-- include the data dictionary -->
        <!--<script src="dataDictionary.js"></script>-->
		<script src="https://colincurtis.github.io/2D_Viewer/dataDictionary.js"></script>

        <!-- include the uids -->
        <!--<script src="uids.js"></script>-->
		<script src="https://colincurtis.github.io/2D_Viewer/uids.js"></script>

        <style>
            html, body {
                overflow: hidden;
                width: 100%;
                height: 100%;
                margin: 0;
                padding: 0;
            }

            #renderCanvas {
                width: 100%;
                height: 100%;
                touch-action: none;
            }
        </style>
    </head>
    <!-- #endregion -->
<body>

    <canvas id="renderCanvas"></canvas>
    <script>
        // Set up canvas, engine
        <!-- #region fold -->
        var canvas = document.getElementById("renderCanvas");
        var engine = null;
        var scene = null;
        var sceneToRender = null;
        var createDefaultEngine = function() { return new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: true, stencil: true }); };
        <!-- #endregion -->

        var dataSet; // the parsed DICOM dataSet as global so we can interact with it from console
        var untilTag = "";
        var file = undefined;

        // Add BabylonJS function getControlByName
        <!--#region fold -->
        BABYLON.GUI.AdvancedDynamicTexture.prototype.executeOnAllControls = function (func, container) {
            // console.log('hijacked eoac run.  container: ', container);
            if (!container) {
                container = this._rootContainer;
            }
            for (var _i = 0, _a = container.children; _i < _a.length; _i++) {
                var child = _a[_i];
                if (child.children) {
                    this.executeOnAllControls(func, child);
                    continue;
                }
                func(child);
            }
        };

        BABYLON.GUI.AdvancedDynamicTexture.prototype.getControlByName = function (name) {
            var foundControl = null;
            if (name) {
                this.executeOnAllControls(function(control) {
                    if(control.name && control.name === name){
                        foundControl = control;
                    }
                }, this._rootContainer);
            }
            return foundControl;
        };
        <!-- #endregion -->

        // Create BabylonJS Scene
        var createScene = function () {
            var scene = new BABYLON.Scene(engine);

            // camera and lights
            <!-- #region fold -->
            // Camera
            var camera = new BABYLON.ArcRotateCamera("Camera", -Math.PI / 2, 1.0, 110, BABYLON.Vector3.Zero(), scene);
            camera.attachControl(canvas, true);
			camera.multiTouchPanAndZoom = true; // Pan on touch screen with two fingers
			camera.speed = 1;

            // Light
            var hemi = new BABYLON.HemisphericLight("toto");
            <!-- #endregion -->

            var tempMaterial = new BABYLON.StandardMaterial("temp"); // GUI changes the "temp" material, then objects' materials copy the "temp"

            // Mesh importing
            <!-- #region fold -->

            // cleanFileNames()
            <!-- #region fold -->
            // Makes website links usable and formats names of imported meshes
            function cleanFileNames(fileNameList) {
                console.log("iin cleanfFileNames")
                // Namify cleans up names for labeling. Expects STL filename structure to be <number>_<name>.<extension (at most 4 characters and without a decimal (ie no .tar.gz))>
                function namify(rawNames) { // causes error if names do not conform
                    var isCharDigit = (function(){ // https://stackoverflow.com/a/32572539/7454736
                      var a = [1,1,1,1,1,1,1,1,1,1];
                      return function(n){
                        return !!a[n] // check if `a` Array has anything in index 'n'. Cast result to boolean
                      }
                    })();
                    let underscoreLoc = rawNames.indexOf("_");
                    let char;
                    let deidentifiedNumber;
                    let allDigits = true;

                    // Remove de-ID from filename if it is all numbers and decimals preceding an underscore at beginning of name
                    if (underscoreLoc !== -1) {                            // If filename has an underscore,
                        for ( char of rawNames.slice(0, underscoreLoc) ) { // loop through characters before underscore
                            if (!isCharDigit(char) && char !== "." && char !== " ") {      // to make sure they are all digits, decimals, and spaces before removing them
                                allDigits = false;
                                break
                            };
                        };
                        if (allDigits) {
                            deidentifiedNumber = rawNames.split(/[_]/)[0];
                            rawNames = /_(.+)/.exec(rawNames)[1]; // Remove numbers and _ in first part of filename
                        };
                    };

                    // Remove extension. Expects extention to be a decimal followed by at most four characters at end of name
                    if (rawNames.includes(".", rawNames.length - 5)) {
                        rawNames = rawNames.replace(/\.[^/\\.]+$/, ""); //https://stackoverflow.com/questions/4250364/how-to-trim-a-file-extension-from-a-string-in-javascript
                    };
                    return [rawNames, deidentifiedNumber];
                };

                // Rename the meshes for better labels
                let cleanMeshNames = [];
                let deIDArray = [];

                for (i = 0, len = fileNameList.length; i < len; i++) {
                    let nameAndDeID = namify(fileNameList[i]);
                    cleanMeshNames.push(nameAndDeID[0]);
                    deIDArray.push(nameAndDeID[1]);
                };
                return [cleanMeshNames, deIDArray];
            };
            <!-- #endregion -->

            // fixURL()
            <!-- #region fold -->
            function fixURL(meshNamesToFix, urlList) { // fix File Hosting website URLs
                let hyperlinks = urlList.slice(0); // if you make hyperlinks = urlList;, they both will reference the same array and will affect one another

                function fixFileHostingURLs(meshNamesToFix, hyperlinks) {
                    //var filenameFromURL = [];
                    for (i = 0; i < hyperlinks.length; i++) {
                        let url = hyperlinks[i];
                        if (url.substring(0, 25).includes("dropbox") && url.length <= 2000) { // remove the 2000 clause
						console.log('here')
                            // Use window.decodeURIComponent(<string>) when file has special characters in name (ie ?,=,&,/ etc), for example this replaces %20 with a space
                            meshNamesToFix[i] = window.decodeURIComponent(url.split("/").pop().split("?").shift()); // Filename needed for BabylonJS to append scene
                            // BabylonJS Dropbox URL format: "https://dl.dropbox.com/s/a3kplcg15ratxmz/249_Arteries.stl" not https://www.dropbox.com/s/a3kplcg15ratxmz/249_Arteries.stl?dl=0
                            if (url.substring(0,25).includes("www")) {
                                url = url.replace('www', 'dl'); // Replace first occurrence of 'www' with 'dl'
                                hyperlinks[i] = url.substr(0, url.lastIndexOf('?')) || url; // Replace last occurrence of ? and everything after it. If not present, returns url unchanged.
                            };
                        };
                    };
                    //console.log("cleanURLList in droboxFileName")
                    //console.log(cleanURLList)
                    return [meshNamesToFix, hyperlinks];
                };
                let fixedMeshNames = [];
                let cleanURLs = [];

                [fixedMeshNames, cleanURLs] = fixFileHostingURLs(meshNamesToFix, hyperlinks); // URLs needed to be adjusted BabylonJS to load

                return [fixedMeshNames, cleanURLs];
            };
            <!-- #endregion -->

            // appendWithMeshes()
            <!-- #region fold -->
            async function appendWithMeshes(listNamesSTLs, listSTLURL) { // Function used when dragging and dropping
                async function actualImport(listNamesSTLs, listSTLURL, meshNumber, i) {
                    let failures = [];
                    await BABYLON.SceneLoader.Append("", listSTLURL[i], scene,
                        function () {
                            console.log("Successfully loaded " + listNamesSTLs[i] + "!");

                            let mesh = scene.meshes[scene.meshes.length - 1]; // Most recently added mesh

                            mesh.name = listNamesSTLs[i];
                            mesh.material = scene.getMaterialByName(listNamesSTLs[i]);

                            // Scene properties
                            <!-- #region fold -->
                            mesh.material.backFaceCulling = false;
                            mesh.material.needDepthPrePass = true;
                            mesh.forceSharedVertices(); // Shade smooth

                            // Create camera framed on loaded meshes
                            scene.createDefaultCameraOrLight(true, true, true);
                            scene.activeCamera.speed = 1;
                            scene.activeCamera.multiTouchPanAndZoom = true;
                            scene.activeCamera.inertia = 0.84;
                            scene.activeCamera.panningSensibility = 150;
                            <!-- #endregion-->

                            // Show progress in console
                            console.log("loaded " + [scene.meshes.length, meshNumber * -1].reduce((a, b) => a + b, 0) + "/" + [listSTLURL.length, meshNumber, meshNumber * -1].reduce((a, b) => a + b, 0));
                            console.log('\n');

                            if (scene.meshes.length === listSTLURL.length + meshNumber) { // Only makes GUI once all meshes are loaded

                                for (let j = 0; j < listSTLURL.length; j++) {
                                    urlList.push(listSTLURL[j]); // Adds new mesh URLs to global list
                                };

                                console.log("going to makeGUI now");
                                scene.executeWhenReady(makeGUI());
                            }
                        },

                        function() { // Runs when mesh is loading
                            //console.log(i)
                            //console.log("Loading " + listNamesSTLs[i] + "(" + i + ")");
                            //console.log("number of meshes: " + scene.meshes.length);
                        },

                        function(error) { // Runs when mesh can't load. Also runs when success or loading functions fail
                            console.error("Error loading model " + listNamesSTLs[i])
                            console.error(error)
                            failures.push(i); // Maybe add a way to ignore these so the rest are loaded, then alert meshes that couldn't load
                        }, ".stl");
                    // Code here runs before code in BABYLON.SceneLoader.Append
                };

                let meshNumber = scene.meshes.length;

                for (let j = 0, len = listSTLURL.length; j < len; j++) { // using i here instead of j will mess stuff up. Should use better variable name
                    //console.log("listSTLURL " + i + ": " + listSTLURL[i]);
                    new BABYLON.StandardMaterial(listNamesSTLs[j], scene);

                    console.log("Right before actualImport. listNamesSTLs (meshList), listSTLURL (urlList)");
                    console.log(listNamesSTLs)
                    console.log(listSTLURL)

                    await actualImport(listNamesSTLs, listSTLURL, meshNumber, j);
                    console.log("attempt " + j)
                };
            };
            <!-- #endregion -->

            // Add default meshes
            <!-- #region fold -->

            let urlList = []; // Enter links to meshes here
            let meshList = []; // Enter filenames here for non-dropbox links

            // Adding built-in STLs

            // To add built-in STLs, set addingRawSTLs to true, add the raw data in quotes to array rawSTLData (use Notepad++, not Atom), and add the names for each in array rawSTLNames
            let addingRawSTLs = false;

            if ( addingRawSTLs ) {
                // Add binary STL data in rawSTLData in quotes using Notepad++ (not Atom). Separate all STLs with commas and put on a new line. Add clean names to rawSTLNames
                <!-- #region fold -->
                let rawSTLData = [];
                <!-- #endregion -->

                let rawSTLNames = []; // Add names of binary STLs here
                let rawSTLURLs = [];

                for (let i = 0; i < rawSTLData.length; i++) {
                    let raw_content = BABYLON.Tools.DecodeBase64(rawSTLData[i]);
                    let blob = new Blob([raw_content]);
                    let url = URL.createObjectURL(blob);

                    rawSTLURLs.push(url)

                    if (rawSTLURLs.length == rawSTLData.length) {
                        appendWithMeshes(rawSTLNames, rawSTLURLs);
                    };
                };
            };

            <!-- #endregion -->

            <!-- #endregion -->

            // GUI
            <!-- #region fold -->
            function makeGUI() {

                let guiList = [];
                let addedMesh = false;
                scene.meshes.forEach(mesh => guiList.push(mesh.name));
                console.log("guiList:")
                for (let n = 0; n < guiList.length; n++) {
                    console.log(guiList[n])
                }

                let cleanFileNamesResult = cleanFileNames(guiList);
                let cleanMeshNames = cleanFileNamesResult[0];
                let deIDs = cleanFileNamesResult[1];
                console.log("deIDs")
                console.log(deIDs);

                console.log(scene.textures[0])

                if (typeof scene.textures[0] != "undefined") {     //  If button is on when adding new mesh,
                    scene.textures[0].dispose();                   //  the previous GUI panel is disposed of
                    addedMesh = true;                              //  but the button will stay on
                }

                var advancedTexture = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");
                //advancedTexture.layer.layerMask = 2; // ?

                // Make panel
                <!-- #region fold -->
                var panel = new BABYLON.GUI.StackPanel("panel");
                panel.width = "200px";
                //panel.height = "100px";
                panel.fontSize = "14px";
                //panel.paddingTop = "20px"; //Cuts bottom 20px off
                panel.paddingLeft = "10px";
                panel.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;
                panel.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP;
                advancedTexture.addControl(panel);
                <!-- #endregion -->

                // removeSliderPicker -- removes slider and color wheel
                <!-- #region fold -->
                function removeSliderPicker() {
                    if (advancedTexture.getControlByName("picker")) {
                        panel.removeControl(advancedTexture.getControlByName("pickerHeader"));
                        panel.removeControl(advancedTexture.getControlByName("picker"));
                    }
                    if (advancedTexture.getControlByName("slider")) {
                        panel.removeControl(advancedTexture.getControlByName("sliderHeader"));
                        panel.removeControl(advancedTexture.getControlByName("slider"));
                    }
                };
                <!-- #endregion -->

                // Remove checkboxes
                <!-- #region fold -->
                function removeCheckboxes() {
                    // Remove checkboxes and their headers. "scene.textures[0]._rootContainer._children[0]._children[0]" is the "Choose Colors" button
                    // Needs to go backwards becuase the array of children shifts up when one is removed
                    //console.log(scene.textures[0]._rootContainer._children[0]._children)
                    for (var len = scene.textures[0]._rootContainer._children[0]._children.length, i = len - 1; i > 0; i--) {
                        scene.textures[0]._rootContainer._children[0]._children[i].dispose();
                    };
                };
                <!-- #endregion -->

                // Transparency slider
                <!-- #region fold -->
                var alphaSlider = function(guiList, checked, parent) {
                    // "Transparency"
                    var sliderText = new BABYLON.GUI.TextBlock("sliderHeader");
                    sliderText.text = "Transparency:";
                    sliderText.height = "40px";
                    sliderText.color = "white";
                    sliderText.textHorizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;
                    sliderText.paddingTop = "10px";

                    // "Alpha Slider"
                    var slider = new BABYLON.GUI.Slider("slider");
                    slider.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;
                    slider.minimum = 0;
                    slider.maximum = 1;
                    slider.color = "green";

                    slider.value = scene.getMaterialByName("temp").alpha;
                    slider.height = "20px";
                    slider.width = "180px";
                    slider.onValueChangedObservable.add(function(value) {
                        scene.getMaterialByName("temp").alpha = value;

                        // Go through checkboxes to see if they are checked. If they are, their alpha changes
                        for (let box = 0; box < checked.length; box++) {
                            if (checked[box]) {
                                scene.getMaterialByName(guiList[box]).alpha = scene.getMaterialByName("temp").alpha;
                            };
                        };
                    });

                    parent.addControl(sliderText);
                    parent.addControl(slider);

                };
                <!-- #endregion -->

                // Color Wheel
                <!-- #region fold -->
                var colorWheel = function(guiList, checked, parent) {
                    console.log("colorWheel")
                    // "Color" header
                    colorText = new BABYLON.GUI.TextBlock("pickerHeader");
                    colorText.text = "Color:";
                    colorText.height = "40px";
                    colorText.color = "white";
                    colorText.textHorizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;
                    colorText.paddingTop = "10px";

                    // Color Wheel
                    var picker = new BABYLON.GUI.ColorPicker("picker");
                    picker.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;
                    picker.value = scene.getMaterialByName("temp").diffuseColor;
                    picker.height = "150px";
                    picker.width = "150px";
                    picker.onValueChangedObservable.add(function(value) { // value is a color#
                        scene.getMaterialByName("temp").diffuseColor = value;

                        // Go through checkboxes to see if they are checked. If they are, their color changes
                        for (var u = 0, len = checked.length; u < len; u++) {
                            if (checked[u]) {
                                scene.getMaterialByName(guiList[u]).diffuseColor = scene.getMaterialByName("temp").diffuseColor;
                            };
                        };
                    });
                    parent.addControl(colorText);
                    parent.addControl(picker);
                };
                <!-- #endregion -->

                // Checkboxes
                <!-- #region fold -->
                function addCheckboxes () {
                    console.log("Checkboxes")
                    var checkboxes = [];
                    var headers = [];

                    for (var i = 0, len = guiList.length; i < len; i++) {
                        checkboxes.push(new BABYLON.GUI.Checkbox(guiList[i] + " Checkbox"));
                        checkboxes[i].width = "20px";
                        checkboxes[i].height = "20px";
                        checkboxes[i].isChecked = false;
                        checkboxes[i].color = "green";

                        // When a checkbox is clicked, see if
                        checkboxes[i].onIsCheckedChangedObservable.add(function(value) {
                            var checked = [];
                            var noneChecked = true;
                            removeSliderPicker();

                            for (var n = 0, len = checkboxes.length; n < len; n++) {
                                if (checkboxes[n].isChecked) {
                                    checked.push(1);
                                } else {
                                    checked.push(0);
                                }
                            }

                            alphaSlider(guiList, checked, panel);
                            colorWheel(guiList, checked, panel);

                            // If all checkboxes are unchecked, remove slider and color wheel
                            for (var m = 0, len = checked.length; m < len; m++) {
                                if (checked[m]) {
                                    noneChecked = false;
                                }
                            }
                            if (noneChecked) {
                                removeSliderPicker(); //Comment out to keep colorwheel and slider visible when everything is unchecked
                            }
                        });

                        headers.push(BABYLON.GUI.Control.AddHeader(checkboxes[i], cleanMeshNames[i], "180px", { isHorizontal: true, controlFirst: true}));
                        headers[i].color = "white";
                        headers[i].height = "20px";
                        headers[i].horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;
                    };

                    for (var i = 0, len = headers.length; i < len; i++) {
                        panel.addControl(headers[i]);
                    };
                    return headers;
                };
                <!-- #endregion -->

                // Export GLB file
                <!-- #region fold -->
                function addGLBExportButton () {
                    console.log("button2")
                    var button2 = BABYLON.GUI.Button.CreateSimpleButton("button2", "Export GLB");
                    button2.height = "40px";
                    button2.width = 0.3;
                    button2.background = "#0394fc";

                    panel.addControl(button2);

                    button2.onPointerUpObservable.add(function() {
                        if (confirm("Download model as a GLB file?")) {
                            BABYLON.GLTF2Export.GLBAsync(scene, "2D Viewer Export").then((glb) => {
                                glb.downloadFiles();
                            });
                        };
                    });
                };

                <!-- #endregion -->

                // "Change Colors" button that adds and removes GUI elements
                <!-- #region fold -->

                console.log("button1")
                var button1 = BABYLON.GUI.Button.CreateSimpleButton("button1", "Change Colors");
                button1.height = "40px";
                button1.width = 0.3;
                button1.background = "green";

                panel.addControl(button1);

                var buttonOn = 1;

                function addUploadButton() {
                    $('#upload').remove(); // Not sure if this line is needed
                    $('body').append('<input id="upload" type="file" multiple style="position: absolute; top: 10px; left: 150px;"/>');
                    $('#upload').on('change', handleFileSelect); // I added "<script src="jquery.min.js"> < /script>" to HTML file otherwise this doesn't work
                };

                function addGUIControls() {

                    addUploadButton();

                    if (scene.meshes.length > 0) {
                        addGLBExportButton();
                    }
                    let headers = addCheckboxes(); // Is "headers" variable necessary?
                    return 0;
                }

                if (addedMesh) {
                    // Keeps the color change button on when adding a new mesh
                    // Does the same thing as turning the "Change Colors" button on
                    buttonOn = addGUIControls();
                }

                button1.onPointerUpObservable.add(function() {

                    if (buttonOn) { // If button is off, turn it on
                        buttonOn = addGUIControls();
                    } else { // Turn button off
                        $('#upload').remove();
                        removeSliderPicker();
                        removeCheckboxes(); // also removes GLB button

                        buttonOn=1;
                        console.log("button off end")
                        //panel.dispose()
                    };
                });

                <!-- #endregion -->

                if (scene.meshes.length == 0) { // If 2D Viewer loads with no meshes,
                    addUploadButton();          // make upload button visible
                    buttonOn = 0;               // and make sure the "change colors" button will remove it with the first click
                };

				// *Optional: Change colors of default binary data meshes
                <!-- #region fold -->
				/*
                scene.getMaterialByName(guiList[0]).diffuseColor = new BABYLON.Color3(0.89, 0.13, 0.13); // Mesh color
                scene.getMaterialByName(guiList[0]).specularColor = new BABYLON.Color3(0.97, 0.67, 0.7); //Reflected color
                //scene.getMaterialByName(guiList[0]).alpha = 0.8; // Transparency
				*/
                <!-- #endregion -->

                console.log("end of makeGUI")
            }; // End of makeGUI
            <!-- #endregion -->

            let fixedMeshUrlList = fixURL(meshList, urlList);
            appendWithMeshes(fixedMeshUrlList[0], fixedMeshUrlList[1]);

            //** Optional: Use the following lines to set the starting color of default meshes from hyperlinks
            <!-- #region fold -->
			/*
            scene.getMaterialByName(meshList[0]).diffuseColor = new BABYLON.Color3(0.89, 0.13, 0.13); // Mesh color
            scene.getMaterialByName(meshList[0]).specularColor = new BABYLON.Color3(0.97, 0.67, 0.7); //Reflected color
			scene.getMaterialByName(meshList[0]).alpha = 0.8; // Transparency
            */
            <!-- #endregion -->

            // Functions to run using "Choose Files" button
            <!-- #region fold -->

            function loadFiles(files, callback) {
                var listNamesSTLs = [];
                var listSTLURL = [];
                // Loop through the FileList and render image files as thumbnails.
                for (var i = 0, f; f = files[i]; i++) {

                    if (f === undefined) {
                        return;

                        // Image
                        <!-- #region fold -->
                    } else if (f.type.match('image.*')) {
                        let reader = new FileReader();

                        // Closure to capture the file information.
                        reader.onload = (function(theFile) {
                            return function (e) {
                                //console.log(e.target.result);
                                var image = e.target.result;
                                var texture = new BABYLON.Texture('data:my_image_name', scene, true,
                                    true, BABYLON.Texture.BILINEAR_SAMPLINGMODE,
                                    null, null, image, true);
                                sphere.material.diffuseTexture = texture;
                            };
                        })(f);
                        // Read in the image file as a data URL.
                        reader.readAsDataURL(f);
                        <!-- #endregion -->

                        // STL
                        <!-- #region fold -->
                    } else if (f.name.slice(f.name.length - 3) == "stl") {
                        // TO DO: differentiate between STL, OBJ, FBX etc.

                        let reader = new FileReader();
                        reader.onload = (function(theFile) {
                            return function (e) {
                                var base64_model_content = e.target.result; // STL file in base64. Can be copy and pasted into a babylonJS file so nothing external needs to be loaded
                                //console.log(theFile.name + " in base64");
                                //console.log(base64_model_content);
                                var raw_content = BABYLON.Tools.DecodeBase64(base64_model_content);
                                var blob = new Blob([raw_content]);
                                var url = URL.createObjectURL(blob);

                                listNamesSTLs.push(theFile.name);
                                listSTLURL.push(url)

                                if (listSTLURL.length == files.length) {
                                    callback(listNamesSTLs, listSTLURL); // appendWithMeshes
                                };
                            };
                        })(f);
                        reader.readAsDataURL(f);
                        <!-- #endregion -->

                        // DICOM
                        <!-- #region fold -->
                    } else if (f.name.slice(f.name.length - 3) == "dcm") {

                        // dumpDataSet. Takes dicom data, extracts STL and name. Returns listSTLURL.
                        <!-- #region fold -->
                        function dumpDataSet(dataSet, output)  // (dicom data, empty array)
                        {
                            function getTag(tag)
                            {
                                var group = tag.substring(1,5); // 0042
                                var element = tag.substring(5,9);  // 0011
                                var tagIndex = ("("+group+","+element+")").toUpperCase();
                                var attr = TAG_DICT[tagIndex]; // Uses dataDictionary.js
                                return attr;
                            }

                            try{
                                var keys = [];
                                for(var propertyName in dataSet.elements) {
                                    keys.push(propertyName);
                                }
                                keys.sort();

                                /* the dataSet.elements object contains properties for each element parsed.  The name of the property
                                // is based on the elements tag and looks like 'xGGGGEEEE' where GGGG is the group number and EEEE is the
                                // element number both with lowercase hexadecimal letters.  For example, the Series Description DICOM element 0008,103E would
                                // be named 'x0008103e'.  Here we iterate over each property (element) so we can build a string describing its
                                // contents to add to the output array */

                                for(var k=0; k < keys.length; k++) {
                                    //TO DO: add more info from tags to get a better filename
                                    var propertyName = keys[k];
                                    var element = dataSet.elements[propertyName];

                                    if(element.tag <= "x0002ffff") {
                                        continue;
                                    }
                                    if(dicomParser.isPrivateTag(element.tag)) {
                                        continue;
                                    }
                                    if(element.length <= 0) {
                                        continue;
                                    }

                                    var tag = getTag(element.tag); //getTag(element.tag).tag = "(0042,0011)"

                                    // Get the name of the STL given by Materialise stored in tag 0042,0010 and assign to var stlName
                                    <!-- #region fold -->
                                    if (tag.tag == "(0042,0010)") {

                                        var data = dicomParser.sharedCopy(dataSet.byteArray, element.dataOffset, element.length);

                                        // Utf8ArrayToStr(array)

                                        // https://stackoverflow.com/questions/8936984/uint8array-to-string-in-javascript
                                        function Utf8ArrayToStr(array) {
                                            var out, i, len, c;
                                            var char2, char3;

                                            out = "";
                                            len = array.length;
                                            i = 0;
                                            while(i < len) {
                                                c = array[i++];
                                                switch(c >> 4)
                                                {
                                                  case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7:
                                                    // 0xxxxxxx
                                                    out += String.fromCharCode(c);
                                                    break;
                                                  case 12: case 13:
                                                    // 110x xxxx   10xx xxxx
                                                    char2 = array[i++];
                                                    out += String.fromCharCode(((c & 0x1F) << 6) | (char2 & 0x3F));
                                                    break;
                                                  case 14:
                                                    // 1110 xxxx  10xx xxxx  10xx xxxx
                                                    char2 = array[i++];
                                                    char3 = array[i++];
                                                    out += String.fromCharCode(((c & 0x0F) << 12) |
                                                                   ((char2 & 0x3F) << 6) |
                                                                   ((char3 & 0x3F) << 0));
                                                    break;
                                                }
                                            }
                                            return out;
                                        }
                                        var stlName = Utf8ArrayToStr(data); // Name given by Materialise, eg "Skull and spine 1 "
                                    }
                                    <!-- #endregion -->

                                    if (tag.tag == "(0042,0011)") {

                                    // The output string begins with the element name (or tag if not in data dictionary), length and VR (if present).  VR is undefined for
                                    // implicit transfer syntaxes

                                        function downloadData(data) {
                                            //var blob = new Blob([data], {type: 'application/octet-stream'}); //"data" will be the STL content, and the content type "application/octet-stream" is a binary file
                                            var blob = new Blob([data]); //"type" is not necessary
                                            var objectURL = URL.createObjectURL(blob); //creates URL that is the download link
                                            //console.log("objectURL")
                                            //console.log(objectURL)
                                            return objectURL
                                        }

                                        var data = dicomParser.sharedCopy(dataSet.byteArray, element.dataOffset, element.length); // 7. dicomParser extracting the STL from the DICM
                                        // 'data' should be all that is needed for getting STL into 2D viewer
                                        //var sopInstanceUid = dataSet.string('x00080018'); // The tag x00080018 Uniquely identifies the SOP Instance (e.g. a specific CT image)
                                        //var fileName = stlName + " - " + sopInstanceUid + "-" + element.tag + "-" + element.dataOffset + ":" + element.length + ".stl"; ////name given to download file.
                                        //var fileName = stlName + ".stl"; //name given to download file.

                                        newURL = downloadData(data);
                                        //listNamesSTLs.push(stlName)

                                    }
                                }
                            } catch(err) {
                                var ex = {
                                    exception: err,
                                    output: output
                                }
                                throw ex;
                            }

                            console.log(stlName + " in base64");
                            console.log(data);

                            return [newURL, stlName]
                        }
                        <!-- #endregion -->

                        let reader = new FileReader(); //  FileReader object lets web applications asynchronously read the contents of files, in this case the object "file"

                        reader.onload = (function(theFile) {
                            return function (e) {
                                // This function knows about variables that exist in parent function "loadFiles"
                                var arrayBuffer = e.target.result;

                                // Here we have the file data as an ArrayBuffer.  dicomParser requires as input a Uint8Array so we create that here
                                var byteArray = new Uint8Array(arrayBuffer);

                                function getDataSet() {
                                    // Invoke the parseDicom function and get back a DataSet object with the contents
                                    try {
                                        var options = {
                                            untilTag: untilTag
                                        };

                                        dataSet = dicomParser.parseDicom(byteArray, options); //Separates data in byteArray to different DICOM tags under "elements" and stores into dataSet

                                        // Here we call dumpDataSet to recursively iterate through the DataSet
                                        var output = [];
                                        var newURLandName = dumpDataSet(dataSet, output);

                                        // Combine the array of strings into one string and add it to the DOM
                                        //document.getElementById('dropZone').innerHTML = '<ul>' + output.join('') + '</ul>';
                                    }
                                // Errors
                                catch(err)
                                    {
                                    }
                                    return newURLandName;
                                };
                                let newURLandName = getDataSet();
                                listSTLURL.push(newURLandName[0]);
                                listNamesSTLs.push(newURLandName[1]);

                                // To Do: alphabetize this list without needing padded zeros

                                if (listSTLURL.length == files.length) {
                                    callback(listNamesSTLs, listSTLURL); // appendWithMeshes
                                };
                            };
                        })(f);
                        //readAsArrayBuffer() method is used to start reading the contents of a specified Blob or File. When the read operation is finished, the readyState becomes DONE,
                        //and the loadend (reader.onload) is triggered. At that time, the result attribute contains an ArrayBuffer representing the file's data.
                        reader.readAsArrayBuffer(f);
                    }
                    <!-- #endregion -->
                }; // end of for loop
            }; // end of loadFiles function

            function handleFileSelect(evt) { // Called by the "Choose Files" button
                var files = evt.target.files; // FileList object
                loadFiles(files, appendWithMeshes);
            };
            <!-- #endregion -->

            return scene;
        }; // End of createScene

<!-- #region fold -->

        var engine;
        try {
            engine = createDefaultEngine();
        } catch(e) {
            console.log("the available createEngine function failed. Creating the default engine instead");
            engine = createDefaultEngine();
        }
        if (!engine) throw 'engine should not be null.';
        scene = createScene();
        sceneToRender = scene

        engine.runRenderLoop(function () {
            if (sceneToRender) {
                sceneToRender.render();
            }
        });

        // Resize
        window.addEventListener("resize", function () {
            engine.resize();
        });

    </script>
</body>
</html>
<!-- #endregion -->
